name: Auto-Update Release

# Add concurrency control to prevent multiple runs
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

on:
  push:
    tags:
      - "v*.*.*" # Trigger on version tags
  workflow_dispatch: # Allow manual triggering
    inputs:
      version:
        description: "Version to release (e.g., v1.0.204)"
        required: true
        default: ""

permissions:
  contents: write
  packages: write
  actions: read

env:
  NODE_VERSION: "20"
  ELECTRON_VERSION: "33.2.0"

jobs:
  # Job to check if this is a new version that needs auto-update
  check-version:
    runs-on: ubuntu-latest
    outputs:
      should-update: ${{ steps.check.outputs.should-update }}
      version: ${{ steps.check.outputs.version }}
    steps:
      - name: Check out code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Check if version needs auto-update
        id: check
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Get the version from the tag or input
          if [ "${{ github.event.inputs.version }}" != "" ]; then
            VERSION="${{ github.event.inputs.version }}"
          else
            VERSION="${GITHUB_REF#refs/tags/}"
          fi

          echo "Checking version: $VERSION"
          echo "Workflow run ID: ${{ github.run_id }}"
          echo "Workflow run number: ${{ github.run_number }}"

          # Always proceed with auto-update for new version tags
          # The concurrency control ensures only one workflow runs per version
          echo "should-update=true" >> $GITHUB_OUTPUT
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "✅ Processing version $VERSION for auto-update"

  # Job to build and publish the auto-update
  auto-update-release:
    needs: check-version
    if: needs.check-version.outputs.should-update == 'true'
    runs-on: macos-14
    steps:
      - name: Check out code
        uses: actions/checkout@v4

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: "npm"

      - name: Install dependencies
        run: npm ci

      - name: Install architecture-specific dependencies
        run: |
          # Install architecture-specific dependencies based on target architecture
          if [ "${{ matrix.arch }}" == "x64" ]; then
            npm i --cpu=x64 --os=darwin @libsql/client-darwin@npm:@libsql/client --no-save
          elif [ "${{ matrix.arch }}" == "arm64" ]; then
            npm i --cpu=arm64 --os=darwin @libsql/client-darwin@npm:@libsql/client --no-save
          fi

      - name: Create data directories
        shell: bash
        run: |
          mkdir -p data
          mkdir -p out/make/data
          mkdir -p release/data
          mkdir -p dist/data

      - name: Install the Apple certificate
        env:
          BUILD_CERTIFICATE_BASE64: ${{ secrets.BUILD_CERTIFICATE_BASE64 }}
          P12_PASSWORD: ${{ secrets.P12_PASSWORD }}
          KEYCHAIN_PASSWORD: ${{ secrets.KEYCHAIN_PASSWORD }}
        run: |
          # Create variables
          CERTIFICATE_PATH=$RUNNER_TEMP/build_certificate.p12
          KEYCHAIN_PATH=$RUNNER_TEMP/app-signing.keychain-db

          # Import certificate from secrets
          echo -n "$BUILD_CERTIFICATE_BASE64" | base64 --decode --output $CERTIFICATE_PATH

          # Create temporary keychain
          security create-keychain -p "$KEYCHAIN_PASSWORD" $KEYCHAIN_PATH
          security set-keychain-settings -lut 21600 $KEYCHAIN_PATH
          security unlock-keychain -p "$KEYCHAIN_PASSWORD" $KEYCHAIN_PATH

          # Import certificate to keychain
          security import $CERTIFICATE_PATH -P "$P12_PASSWORD" -A -t cert -f pkcs12 -k $KEYCHAIN_PATH

          # Make the keychain the default
          security default-keychain -s $KEYCHAIN_PATH

          # Add keychain to search list
          security list-keychain -d user -s $KEYCHAIN_PATH $(security list-keychains -d user | tr -d '"')

          # Verify certificate import
          echo "Verifying certificate..."
          security find-identity -v

          # Allow codesign to access keychain
          security set-key-partition-list -S apple-tool:,apple:,codesign: -s -k "$KEYCHAIN_PASSWORD" $KEYCHAIN_PATH

      - name: Build for macOS (both architectures)
        env:
          APPLE_SIGNING_IDENTITY: ${{ secrets.APPLE_SIGNING_IDENTITY }}
          APPLE_ID: ${{ secrets.APPLE_ID }}
          APPLE_ID_PASSWORD: ${{ secrets.APPLE_ID_PASSWORD }}
          APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
          NODE_ENV: production
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          VITE_AXIOM_TOKEN: ${{ secrets.VITE_AXIOM_TOKEN }}
          VITE_AXIOM_ORG_ID: ${{ secrets.VITE_AXIOM_ORG_ID }}
          VITE_AXIOM_DATASET: ${{ secrets.VITE_AXIOM_DATASET }}
          VITE_PUBLIC_POSTHOG_KEY: ${{ secrets.VITE_PUBLIC_POSTHOG_KEY }}
          VITE_PUBLIC_POSTHOG_HOST: ${{ secrets.VITE_PUBLIC_POSTHOG_HOST }}
        run: |
          echo "Building auto-update for both architectures (x64 and arm64)"
          echo "Version: ${{ needs.check-version.outputs.version }}"

          # Verify keychain access
          security unlock-keychain -p "$KEYCHAIN_PASSWORD" $RUNNER_TEMP/app-signing.keychain-db

          # Build for both architectures to ensure ZIP files are created
          echo "🔨 Building for x64 architecture..."
          npm run publish -- --arch=x64

          echo "🔨 Building for arm64 architecture..."
          npm run publish -- --arch=arm64

          # Verify ZIP files were created for update.electronjs.org
          echo "🔍 Checking for ZIP files..."
          find out/make -name "*.zip" -type f
          echo "📦 ZIP files found:"
          ls -la out/make/*.zip 2>/dev/null || echo "No ZIP files found"

          # Check the exact naming pattern of generated files
          echo "🔍 All generated files in out/make:"
          find out/make -type f -name "*$VERSION*" | sort

          # Check if any files match the update.electronjs.org pattern
          echo "🔍 Files matching update.electronjs.org pattern .*-(mac|darwin|osx).*.zip:"
          find out/make -type f -name "*$VERSION*" | grep -E ".*-(mac|darwin|osx).*\.zip" || echo "No files match the required pattern"

          # If ZIP files are not created by MakerZIP, create them manually
          echo "🔧 Creating ZIP files manually if needed..."
          VERSION="${{ needs.check-version.outputs.version }}"

          # Check for x64 build directory
          X64_DIR="out/make/itracksy-$VERSION-x64"
          if [ -d "$X64_DIR" ]; then
            echo "📦 Creating ZIP for x64 architecture..."
            cd "$X64_DIR"
            zip -r "../itracksy-$VERSION-mac-x64.zip" .
            cd - > /dev/null
          fi

          # Check for arm64 build directory
          ARM64_DIR="out/make/itracksy-$VERSION-arm64"
          if [ -d "$ARM64_DIR" ]; then
            echo "📦 Creating ZIP for arm64 architecture..."
            cd "$ARM64_DIR"
            zip -r "../itracksy-$VERSION-mac-arm64.zip" .
            cd - > /dev/null
          fi

          # Verify ZIP files were created
          echo "🔍 Final ZIP files check:"
          find out/make -name "*.zip" -type f

      - name: Clean up keychain
        run: |
          security delete-keychain $RUNNER_TEMP/app-signing.keychain-db

      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: macos-both-archs-${{ needs.check-version.outputs.version }}
          path: |
            out/make/**/*.dmg
            out/make/**/*.zip
            out/make/**/*.tar.gz
          retention-days: 30

  # Job to create GitHub release and publish auto-update
  create-release:
    needs: [check-version, auto-update-release]
    if: needs.check-version.outputs.should-update == 'true'
    runs-on: ubuntu-latest
    steps:
      - name: Check out code
        uses: actions/checkout@v4

      - name: Download all build artifacts
        uses: actions/download-artifact@v4
        with:
          pattern: macos-both-archs-${{ needs.check-version.outputs.version }}

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: "npm"

      - name: Install dependencies
        run: npm ci

      - name: Generate release notes
        id: release-notes
        run: |
          VERSION="${{ needs.check-version.outputs.version }}"
          PREVIOUS_TAG=$(git describe --tags --abbrev=0 $VERSION^ 2>/dev/null || echo "")

          if [ -n "$PREVIOUS_TAG" ]; then
            # Generate changelog from previous tag
            CHANGELOG=$(git log --pretty=format:"- %s" $PREVIOUS_TAG..$VERSION --grep="^feat\|^fix\|^docs\|^style\|^refactor\|^test\|^chore" --invert-grep --grep="^Merge\|^Revert" || echo "No conventional commits found")
          else
            CHANGELOG="Initial release"
          fi

          # Create release notes
          RELEASE_NOTES="## What's New in $VERSION\n\n$CHANGELOG\n\n## Auto-Update\n\nThis release includes automatic update functionality. Users will be notified of updates and can install them automatically.\n\n## Installation\n\nDownload the appropriate installer for your system architecture:\n- **macOS Intel (x64)**: Use the .dmg file\n- **macOS Apple Silicon (ARM64)**: Use the .dmg file\n\n## Auto-Update Features\n\n- Automatic update detection\n- Seamless installation process\n- Background download and installation\n- User notification system\n\n## Auto-Update Files\n\nThis release includes ZIP files required by the auto-update system:\n- **macOS Intel (x64)**: `itracksy-$VERSION-mac-x64.zip`\n- **macOS Apple Silicon (ARM64)**: `itracksy-$VERSION-mac-arm64.zip`"

          echo "release-notes<<EOF" >> $GITHUB_OUTPUT
          echo "$RELEASE_NOTES" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Check if release already exists
        id: check-release
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          VERSION="${{ needs.check-version.outputs.version }}"

          echo "🔍 DEBUG: Checking if release exists for version: $VERSION"
          echo "🔍 DEBUG: Repository: ${{ github.repository }}"

          # Check if release already exists
          RELEASE_EXISTS=$(gh api repos/${{ github.repository }}/releases/tags/$VERSION --jq '.id' 2>/dev/null || echo "")

          echo "🔍 DEBUG: Raw API response: $RELEASE_EXISTS"

          if [ -n "$RELEASE_EXISTS" ]; then
            echo "release-exists=true" >> $GITHUB_OUTPUT
            echo "release-id=$RELEASE_EXISTS" >> $GITHUB_OUTPUT
            echo "ℹ️  Release $VERSION already exists (ID: $RELEASE_EXISTS)"
          else
            echo "release-exists=false" >> $GITHUB_OUTPUT
            echo "release-id=" >> $GITHUB_OUTPUT
            echo "✅ Release $VERSION does not exist - will create new"
          fi

          echo "🔍 DEBUG: Final outputs:"
          echo "  - release-exists: ${{ steps.check-release.outputs.release-exists }}"
          echo "  - release-id: ${{ steps.check-release.outputs.release-id }}"

      - name: Debug - Check current state
        run: |
          echo "🔍 DEBUG: Current working directory: $(pwd)"
          echo "🔍 DEBUG: Directory contents:"
          ls -la
          echo ""
          echo "🔍 DEBUG: Release check output:"
          echo "  - release-exists: ${{ steps.check-release.outputs.release-exists }}"
          echo "  - release-id: ${{ steps.check-release.outputs.release-id }}"
          echo ""
          echo "🔍 DEBUG: Release notes output:"
          echo "  - release-notes: ${{ steps.release-notes.outputs.release-notes }}"

      - name: Create GitHub Release
        id: create-release
        if: steps.check-release.outputs.release-exists != 'true'
        uses: actions/create-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: ${{ needs.check-version.outputs.version }}
          release_name: iTracksy ${{ needs.check-version.outputs.version }}
          body: ${{ steps.release-notes.outputs.release-notes }}
          draft: false
          prerelease: false

      - name: Publish to GitHub Releases
        if: steps.check-release.outputs.release-exists == 'true' || steps.create-release.result == 'success'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          VERSION="${{ needs.check-version.outputs.version }}"
          echo "🚀 Publishing assets for version $VERSION"

          # Hardcoded paths based on Electron Forge output structure
          # macOS builds
          MACOS_X64_DMG="out/make/itracksy-$VERSION-x64.dmg"
          MACOS_ARM64_DMG="out/make/itracksy-$VERSION-arm64.dmg"

          # Check if files exist and upload them
          if [ -f "$MACOS_X64_DMG" ]; then
            echo "📦 Uploading macOS Intel (x64): $MACOS_X64_DMG"
            gh release upload "$VERSION" "$MACOS_X64_DMG" --clobber
          else
            echo "⚠️  macOS Intel (x64) DMG not found: $MACOS_X64_DMG"
          fi

          if [ -f "$MACOS_ARM64_DMG" ]; then
            echo "📦 Uploading macOS Apple Silicon (ARM64): $MACOS_ARM64_DMG"
            gh release upload "$VERSION" "$MACOS_ARM64_DMG" --clobber
          else
            echo "⚠️  macOS Apple Silicon (ARM64) DMG not found: $MACOS_ARM64_DMG"
          fi

          # Check for ZIP files required by update.electronjs.org
          # Must match pattern: .*-(mac|darwin|osx).*.zip
          MACOS_ZIP_X64="out/make/itracksy-$VERSION-mac-x64.zip"
          MACOS_ZIP_ARM64="out/make/itracksy-$VERSION-mac-arm64.zip"

          if [ -f "$MACOS_ZIP_X64" ]; then
            echo "📦 Uploading macOS Intel (x64) ZIP: $MACOS_ZIP_X64"
            gh release upload "$VERSION" "$MACOS_ZIP_X64" --clobber
          else
            echo "⚠️  macOS Intel (x64) ZIP not found: $MACOS_ZIP_X64"
          fi

          if [ -f "$MACOS_ZIP_ARM64" ]; then
            echo "📦 Uploading macOS Apple Silicon (ARM64) ZIP: $MACOS_ZIP_ARM64"
            gh release upload "$VERSION" "$MACOS_ZIP_ARM64" --clobber
          else
            echo "⚠️  macOS Apple Silicon (ARM64) ZIP not found: $MACOS_ZIP_ARM64"
          fi

          # Also check for any other ZIP files that might exist
          OTHER_ZIP_FILES=$(find out/make -name "*.zip" -type f 2>/dev/null | grep -v "$MACOS_ZIP_X64" | grep -v "$MACOS_ZIP_ARM64" || echo "")
          if [ -n "$OTHER_ZIP_FILES" ]; then
            echo "📦 Found additional ZIP files, uploading:"
            echo "$OTHER_ZIP_FILES" | while read -r file; do
              if [ -f "$file" ]; then
                echo "  - Uploading: $file"
                gh release upload "$VERSION" "$file" --clobber
              fi
            done
          fi

          echo "✅ Auto-update release $VERSION published successfully!"

      - name: Notify auto-update success
        run: |
          echo "🚀 Auto-update release ${{ needs.check-version.outputs.version }} has been published!"
          echo "📱 Users will now receive automatic updates through the update.electronjs.org service"
          echo "🔗 Release URL: https://github.com/${{ github.repository }}/releases/tag/${{ needs.check-version.outputs.version }}"

  # Job to verify auto-update configuration
  verify-auto-update:
    needs: [check-version, create-release]
    if: needs.check-version.outputs.should-update == 'true'
    runs-on: ubuntu-latest
    steps:
      - name: Check out code
        uses: actions/checkout@v4

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: "npm"

      - name: Install dependencies
        run: npm ci

      - name: Verify auto-update configuration
        run: |
          echo "🔍 Verifying auto-update configuration..."

          # Check if update-electron-app is properly configured
          if npm list update-electron-app > /dev/null 2>&1; then
            echo "✅ update-electron-app is installed"
          else
            echo "❌ update-electron-app is not installed"
            exit 1
          fi

          # Check if the main process has auto-update code
          if grep -q "updateElectronApp" src/main.ts; then
            echo "✅ Auto-update code is present in main process"
          else
            echo "❌ Auto-update code is missing from main process"
            exit 1
          fi

          # Check if forge config has GitHub publisher (optional since we handle publishing in workflow)
          if grep -q "PublisherGithub" forge.config.ts; then
            echo "✅ GitHub publisher is configured in forge config"
          else
            echo "ℹ️  GitHub publisher not in forge config (handled by workflow)"
          fi

          echo "✅ Auto-update configuration verification passed!"

      - name: Test auto-update endpoint
        run: |
          VERSION="${{ needs.check-version.outputs.version }}"
          REPO="${{ github.repository }}"

          echo "🔍 Testing auto-update endpoint..."

          # Test the update.electronjs.org endpoint
          UPDATE_URL="https://update.electronjs.org/$REPO/darwin/$VERSION"
          echo "Testing URL: $UPDATE_URL"

          # Make a request to check if the update endpoint is working
          RESPONSE=$(curl -s -o /dev/null -w "%{http_code}" "$UPDATE_URL" || echo "000")

          if [ "$RESPONSE" = "200" ] || [ "$RESPONSE" = "404" ]; then
            echo "✅ Auto-update endpoint is accessible (HTTP $RESPONSE)"
          else
            echo "⚠️  Auto-update endpoint returned HTTP $RESPONSE"
          fi

          # Check if ZIP files are accessible in the GitHub release
          echo "🔍 Verifying ZIP files in GitHub release..."

          # Get the release assets
          ASSETS=$(gh api repos/$REPO/releases/tags/$VERSION --jq '.assets[] | .name' 2>/dev/null || echo "")

          if [ -n "$ASSETS" ]; then
            echo "📦 Release assets found:"
            echo "$ASSETS"

            # Check for required ZIP files
            if echo "$ASSETS" | grep -q "itracksy-$VERSION-mac-x64.zip"; then
              echo "✅ x64 ZIP file found in release"
            else
              echo "❌ x64 ZIP file missing from release"
            fi

            if echo "$ASSETS" | grep -q "itracksy-$VERSION-mac-arm64.zip"; then
              echo "✅ arm64 ZIP file found in release"
            else
              echo "❌ arm64 ZIP file missing from release"
            fi
          else
            echo "⚠️  No release assets found"
          fi

  # Job to clean up and finalize
  cleanup:
    needs: [check-version, create-release, verify-auto-update]
    if: always()
    runs-on: ubuntu-latest
    steps:
      - name: Check workflow status
        run: |
          if [ "${{ needs.check-version.result }}" = "success" ] && \
             [ "${{ needs.create-release.result }}" = "success" ] && \
             [ "${{ needs.verify-auto-update.result }}" = "success" ]; then
            echo "🎉 Auto-update release workflow completed successfully!"
            echo "📱 Users will now receive automatic updates for version ${{ needs.check-version.outputs.version }}"
          else
            echo "⚠️  Auto-update release workflow had some issues:"
            echo "   Check Version: ${{ needs.check-version.result }}"
            echo "   Create Release: ${{ needs.create-release.result }}"
            echo "   Verify Auto-Update: ${{ needs.verify-auto-update.result }}"
          fi
